МОЖЕТ - но не обязательно.
ЗАПРЕЩЕНО - не делайте так.
ДОЛЖНЫ - только так и не иначе.

АРХИТЕКТУРНЫЕ УРОВНИ
...описать

Основых явных уровня два:
- Инфраструктурный уровень. Запускает какой-то СЦЕНАРИЙ ИСПОЛЬЗОВАНИЯ и сохраняет/передаёт результаты.
    Для этого используется какой то фреймворк или другие компоненты роутинга запросов или запуска команд.
    Так же здесь находятся реализации хранилищь данных, менеджеры сообщений, механизмы кеширования.
    В общем все что казасетя ввода и вывода информации в программу.
- Предметный уровень. Описывает и реализует СЦЕНАРИИ ИСПОЛЬЗОВАНИЯ. (Здесь 80% нашей работы)

Главное правило при такой организации: Инфраструктурный уровень зависит от Предметного, и никогда на оборот.

СЦЕНАРИЙ ИСПОЛЬЗОВАНИЯ
...описать

Для реализации СЦЕНАРИЯ ИСПОЛЬЗОВАНИЯ, Предметный уровень дополнительно МОЖЕТ разделиться на два.

У нас распрастранен стиль анемичного предметного уровня. Появляется уровень сушности.
Бизнес логика отделена от структур данных и находится в методах сервисах.
Сущности описывают структуру данных и не содержат бизнес логики.
Зависимость уровней выглядит так:
Инфраструктурный зависит от Педметного, который зависит от уровня сущности (и никогда на оборот)
В коде, предметный уровень представлен неймспейсом Service. Уровено сущностей представлен неймспейсом Entity

Для предметно-ориентированного стиля, выделяется отдельно Прикладной уровень.
Тогда получается такая цепочка зависимостей:
Инфраструктурный зависит от Прикладного, который зависит от Педметного (и никогда на оборот)
В коде, прикладной уровень представлени неймспейсом Application. Предметный уровень представлен неймспейсом Domain

Так, как СЦЕНАРИИ ИСПОЛЬЗОВАНИЯ ДОЛЖНЫ оформаляться в виде КОМПОНЕНТА,
выбор стиля реализации на усмотрения разработчика КОМПОНЕНТА.

Как уже упоминалось выше, зависимость между уровнями однонаправленная.
Текущий уровень ДОЛЖЕН зависить только от ПУБЛИЧНЫХ ТИПОВ следующего по глубине уровня (и никогда на оборот).
ПУБЛИЧНЫЕ ТИПЫ представлены в виде интерфейсов и классов.
Потому зависимость проявляется в виде наследование и композиции.
...нужен пример

КОМПОНЕНТ
Программная единица, реализующая некоторую функциональность и предоставляющая ПУБЛИЧНЫЙ интерфейс к ней.
Ялвяется единицей развертывания, что позволяет придерживатся принципа повторного использования.
Например воркер выполняет команды которые зависят от компонента.
Веб сервер обрабатывает запросы короые зависят от компонента.
И воркер и веб-сервер используют компонент, но ничего не знают друг о друге.
...описать остальные принципи разработки реализуемые компонентом.

ДОЛЖЕН имееть версию ...описать принцип нумерации.

КОМПОНЕНТ предоставляет И реализует один ИЛИ несколько ПУБЛИЧНЫХ интерфейсов.
Для описание ПУБЛИЧНЫХ интерфейсов ДОЛЖНЫ использоваться ПУБЛИЧНЫЕ ТИПЫ, если такие есть.
К ПУБЛИЧНЫМ ТИПАМ относятся классы структур данных и классы ПРОВЕРЯЕМЫХ исключений.
ПУБЛИЧНЫЕ ТИПЫ не должны содержать никакой БИЗНЕС ЛОГИКИ.
В коде интерфейсы разпологаются в корневом неймспейсе КОМПОНЕНТА. Это скрывает аспекты стиля реализации (описано выше).
Сохраняется возможность изменить стиль реализации в будущем. Например если набор бизнес правил увеличится, можно перейти
 на предметно ориентированный стиль.

Все остальные классы и интерфейсы КОМПОНЕНТА являются ПРИВАТНЫМИ.

КОМПОНЕНТ МОЖЕТ зависить от других КОМПОНЕНТОВ.
Зависимость ДОЛЖНА быть от ПУБЛИЧНЫХ интерфейсов.
ЗАПРЕЩЕНО создавать зависимость от ПРИВАТНЫХ реализаций.

СУЩНОСТИ не могут выступать ПУБЛИЧНЫМ ТИПОМ данных потому, что находятся на внутреннем АРХИТЕКТУРНОМ УРОВНЕ.
В разрез анемечному стилю, СУЩНОСТИ МОГУТ содержать бизнес логику, если интересно почитейте про предметно-ориентированный стиль.

КОМПОНЕНТ МОЖЕТ описывать интерфейсы адапретов СЕРВИСОВ других КОМПОНЕТНОВ и реализовывать их.
Характерно для предметно-ориентированного стиля и удобно для приведения ПУБЛИЧНЫХ ТИПОВ других КОМПОНЕНТАМ к собственным ТИПАМ (и наоборот).
Реализация адаптеров ДОЛЖНА быть на инфраструтурном уровне.
Такой стиль работы с другими КОМПОНЕНТАМИ более строгий, но не обязательный.
С точки зрения архитектуры, пока реализация адаптеров является частью компонента, количество зависимостей компонента не уменьшается.

ПРОВЕРЯЕМЫЕ ИСКЛЮЧЕНИЯ ДОЛЖНЫ бросаться в методах содержащих логику.
Методам доступа к данным, без логики, достаточно nullable результата.

ПРОВЕРЯЕМЫЕ ИСКЛЮЧЕНИЯ МОГУТ быть ПУБЛИЧНЫМ ТИПОМ.

ПРОВЕРЯЕМЫЕ ИСКЛЮЧЕНИЯ другого КОМПОНЕНТА НЕЛЬЗЯ пробрасывать.
Если пробросить их, не имея зависимости от другого КОМПОНЕНТА, клиент не сможет организовать проверку ИСКЛЮЧЕНИЯ. (появится непойманое исключение)
Один из способов работы с ИСКЛЮЧЕНИЯМИ другого КОМПОНЕНТА - адаптеры сервисов других КОМПОНЕНТОВ (описано выше).
Адаптер реализует удобную стратегию обработки: преобразовать в своё ИСКЛЮЧЕНИЕ, или же привести к nullable результату.

СЕРВИС
ПУБЛИЧНЫЙ интерфейс описывающий методы выполнения СЦЕНАРИЕВ ИСПОЛЬЗОВАНИЯ, предаставляемых КОМПОНЕНТОМ.
...описать подробнее

КОМАНДЫ
...описать

ПРОЕКЦИИ
...описать

Реализация ПУБЛИЧНЫХ интерфейсов ДОЛЖНА находится неймспейсе Service для анемечного стиля ИЛИ в неймспейсе Application
для предметно-ориентированного стиля.

У одного КОМПОНЕНТА МОЖЕТ быть больше одного хранилища. Если хранилишь несколько, вомзожно нарушается принцип единой ответсвенности
и нужно разделить КОМПОНЕНТ на несколько.
...расписать организацию хранилищь

Com контроллеры/команды/консумер ДОЛЖНЫ зависеть ТОЛЬКО от Com компонентов ИЛИ фреймворка.
Из выше сказанного ОДИН контроллеры/команды/консумер зависит от ОДНОГО компонента.
Так же получается, что Контроллеры/команды/консумер НЕ ДОЛЖНЫ использовать ЧУЖИЕ компоненты.
Закон Диметры для контроллеров/команд/консумеров распространяется ТОЛЬКО при обращении к интерфейсам компонента,
при обащении к объектам фреймворка - допускается нарушение.
Контроллеры/команды/консумены НЕ покрываются юнит-тестами.

настройка композера для привтных пакетов.
Реализация адаптеров сервисов в интфраструктуре?
Посчитать количественные величины по книге Дяди Боба.

https://www.foreach.be/blog/selecting-a-software-architecture?lang=nl

Модуль = Компонент (=) Пакет
Компоненты — это единицы развертывания. Они представляют наименьшие сущности, которые можно развертывать в составе системы.
«Группа функциональных возможностей, находящихся за общим чистым интерфейсом, которые постоянно находятся внутри среды выполнения, такой как приложение».
Модули - Программные единицы, реализующие некоторую функциональность и предоставляющие интерфейс к ней.

Пакет компонентов = Контейнер
